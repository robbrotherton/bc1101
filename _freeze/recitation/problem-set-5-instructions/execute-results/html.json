{
  "hash": "602248553d648b5fe205471371ebccb5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Problem Set 5\nsubtitle: Hypothesis testing\n\nformat: html\nsidebar: recitation\nnavbar: false\nexecute: \n  echo: true\n---\n\n# Part 1. Effect size and statistical power\n\n::: {.content-visible when-format=\"html\"}\n## Instructions\n\n### Effect size\n\nCohen's $d$ is simple to calculate: It is the mean difference divided by standard deviation.\n\nSo if you have a population with mean 100 and standard deviation 15, and you administer a treatment which produces a sample mean of 106, Cohen's $d$ would be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(106 - 100) / 15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4\n```\n\n\n:::\n:::\n\n\n### Statistical power\n\nSuppose we're measuring reaction times in milliseconds. A sample $n = 40$ is selected from a normally-distributed population with $\\mu = 75$ and $\\sigma = 12$, and a treatment is administered to the sample. The treatment is expected to increase scores by an average of $4$ msec. We plan to use a two-tailed hypothesis test using $\\alpha = .05$.\n\nStep 1: Calculate the standard error of the mean\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd_err <- 12/sqrt(40)\n```\n:::\n\n\nStep 2: multiply the critical $z$-scores by the standard error of the mean and add to the population mean to find the range of means that would produce a Type II error. We can put two values into the `qnorm()` function using the `c()` function. This way, we will get both of the means we're looking for using a single line of code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange <- 75 + qnorm(c(.025, .975)) * std_err \n\nrange\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 71.28123 78.71877\n```\n\n\n:::\n:::\n\n\n...which tells us that any mean between 71.28 and 78.72 would lead us to fail to reject the null hypothesis\n\nstep 3: Calculate beta. Assuming that the treatment worked and thus the new mean is 79, determine what proportion of sample means fall within that range.\n\nOne way would be to subtract the lower value from the higher value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta <- pnorm(78.72, mean = 79, sd = std_err) - pnorm(71.28, mean = 79, sd = std_err) \n\nbeta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4413163\n```\n\n\n:::\n:::\n\n\nA slightly easier way would be to use the `diff()` function. If you feed two numbers into the diff function, it will figure out the difference between them. You should get approximately the same answer. (Since the first method involved rounding the numbers along the way, there will be a slight difference.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nareas <- pnorm(range, mean=79, sd=std_err) \n\nbeta <- diff(areas) \n\nbeta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4410604\n```\n\n\n:::\n:::\n\n\nStep 4: Power = 1 - beta\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - beta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5589396\n```\n\n\n:::\n:::\n\n\nWith a 1-tailed test, you don't have to deal with the range between 2 means. You should just find the single critical mean, and figure out the probability of obtaining a mean less than that value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd_err <- 12/sqrt(40) \n\nm_critical <- 75 + qnorm(.95) * std_err \n\nbeta <- pnorm(m_critical, mean=79, sd=std_err) \n\n1 - beta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6784366\n```\n\n\n:::\n:::\n\n:::\n\n:::: {.content-hidden when-format=\"pdf\"}\n::: {.callout-tip collapse=\"false\"}\n## Bonus\n\nThe package `pwr` can do power calculations for you. It's worth getting to grips with, but if you use it, do the calculations manually as well at least the first couple of times to make sure you're getting the right answers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pwr) \n\npwr.norm.test(d=(79-75)/12, # d is the (known or anticipated) effect size; (M - mu)/SD \n              n=40, # n is the sample size \n              sig.level = .05, # sig.level is alpha \n              alternative = \"two.sided\") # this is the alternative hypothesis (greater, less, or two.sided)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Mean power calculation for normal distribution with known variance \n\n              d = 0.3333333\n              n = 40\n      sig.level = 0.05\n          power = 0.5589396\n    alternative = two.sided\n```\n\n\n:::\n\n```{.r .cell-code}\npwr.norm.test(d = (79-75)/12, n = 40, sig.level = .05, alternative = \"greater\") # one-tailed power\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Mean power calculation for normal distribution with known variance \n\n              d = 0.3333333\n              n = 40\n      sig.level = 0.05\n          power = 0.6784366\n    alternative = greater\n```\n\n\n:::\n:::\n\n:::\n::::\n\n# Part 2. Hypothesis testing\n\n::: {.content-hidden when-format=\"pdf\"}\n## Instructions\n\nAs in the lecture, you can think about hypothesis testing as a series of steps to follow\n\n**Step 1: State your hypotheses.** R can't do this for you - you just have to think about the question and formulate your null ($H_0$) and alternative ($H_1$) hypotheses.\n\n**Step 2: Set decision criteria.** The questions below will tell you what alpha to use. Suppose we're using $\\alpha = .05$, and a two-tailed test. For a $z$-test, find the critical values using `qnorm()`.\n\nFor a one-tailed test, just put in the proportion you want to be your critical region:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(.05) # If you expect a decrease\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.644854\n```\n\n\n:::\n\n```{.r .cell-code}\nqnorm(.95) # If you expect an increase\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.644854\n```\n\n\n:::\n\n```{.r .cell-code}\nqnorm(.05, lower.tail = FALSE) # Also works for an increase\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.644854\n```\n\n\n:::\n:::\n\n\nFor a two-tailed test we have two critical regions, each containing alpha divided by 2. We can feed both into `qnorm()` at the same time using `c()`, and it will give us two answers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(c(0.025, 0.975))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.959964  1.959964\n```\n\n\n:::\n:::\n\n\n**Step 3: Calculate your test statistic.** Do this by plugging the appropriate values into the relevant equation. (For other tests, there may be R functions you can use, but there's no built-in function for a $z$-test)\n\n**Step 4: Decide.** Compare your calculated test statistic with the critical values to determine whether your sample is within the critical region(s), and thus whether to reject the null.\n:::\n\n:::: {.content-hidden when-format=\"pdf\"}\n::: {.callout-tip collapse=\"false\"}\n## Bonus\n\nThere is no built-in function for doing $z$-tests using real data, because researchers don't need to do it very often. For a fun challenge you could try creating your own function.\n:::\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}