{
  "hash": "dc7ae34c409c6812a1af9c3dd92aed98",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Problem Set 4\nsubtitle: $z$-scores and Probability\n\nformat: html\nsidebar: recitation\nnavbar: false\nexecute: \n  echo: true\n---\n\n::: {.content-hidden when-format=\"pdf\"}\n## Instructions\n\nThe old-fashioned way to find the probability (the proportion of the distribution) associated with particular $z$-scores would be to look the score up in a $z$-score table (Unit Normal Table). R can do this for us much more easily, but it's a good idea to check your first few answers against a table, e.g. <https://www.westga.edu/academics/research/vrc/assets/docs/UnitNormalTable.pdf>\n\nIf you have a $z$-score in mind and want to know the associated probability, use the `pnorm()` function. By default, `pnorm()` assumes we want the proportion of the distribution to the left of the $z$-score we specify.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9772499\n```\n\n\n:::\n:::\n\n\nSo .9772499, or \\~98% of scores in a normal distribution are less than $z = 2$.\n\nTo get the proportion to the right, we set the `lower.tail` argument to `FALSE` (i.e. we want the upper tail)\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(2, lower.tail = FALSE) # .02275013, or ~2% of scores are greater than z = 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02275013\n```\n\n\n:::\n:::\n\n\nThink about how R's `lower.tail` distinction corresponds to the \"body\" vs. \"tail\" distinction. It's not always necessarily the same.\n\nTo find the proportion of the normal distribution between two $z$-scores, one way would be to subtract p(lower score) from p(higher score)\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(.25) - pnorm(-.25) # Just under .20, or 20% is between z = -.25 and z = .25\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1974127\n```\n\n\n:::\n:::\n\n\nNote that the slightly different code below gives the same answer. Do you understand why? Either solution is perfectly acceptable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(-.25, lower.tail = F) - pnorm(.25, lower.tail = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1974127\n```\n\n\n:::\n:::\n\n\nWhen you have a proportion (quantile) in mind and want to find the associated z-score, `qnorm()` is the appropriate function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.644854\n```\n\n\n:::\n:::\n\n\nThat tells us that the cutoff for the lowest 5% of the distribution corresponds to $z = -1.64$. `qnorm()` also accepts the `lower.tail` argument\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(.05, lower.tail = FALSE) # Now we get a positive value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.644854\n```\n\n\n:::\n:::\n\n\nThe line below gives the same answer. Do you understand why?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(.95, lower.tail = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.644854\n```\n\n\n:::\n:::\n\n\nThe last thing you need to know for the questions below is that both `pnorm()` and `qnorm()` have optional arguments for the mean and SD of the distribution. That is, if we have raw scores, we don't have to convert to z-scores to use these functions, we can specify the appropriate values\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(130, mean = 100, sd = 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9772499\n```\n\n\n:::\n:::\n\n:::\n\n:::: {.content-hidden when-format=\"pdf\"}\n::: {.callout-tip collapse=\"false\"}\n## Sketching distributions\n\nWith the kinds of questions that follow, I find it massively useful to sketch a rough normal curve on a piece of paper and mark approximately where the $z$-scores would go, and shade in the corresponding probability region. My strong recommendation is that you do that on a piece of paper.\n\nIf are falling in love with R and `ggplot` in particular, however, you can draw distributions right here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot() +\n  stat_function(fun = dnorm, \n                geom = \"density\", \n                xlim = c(-2, 2), \n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-9-1.png){width=192}\n:::\n:::\n\n\nThe first `stat_function()` layer draws the red shaded region, and the second one draws the black line of the full normal curve. I picked `c(-4, 4)` for the `xlim`s of the full curve because that's wide enough to show the ends tailing off to 0. For the shaded region, `c(-2, 2)` was just an arbitrary choice.\n\nSay you wanted to shade the region below $z = 2$. You could use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  stat_function(fun = dnorm, \n                geom = \"density\", \n                xlim = c(-4, 2), # xlim goes up to 2\n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-10-1.png){width=192}\n:::\n:::\n\n\nThat gives you a good visual sense that most of the distribution is below that point, so when `pnorm(2)` gives you the answer, it should make sense.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9772499\n```\n\n\n:::\n:::\n\n\nOr say you want to see what the highest 20% of the distribution looks like.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  stat_function(fun = dnorm, geom = \"density\", \n                xlim = c(qnorm(0.2, lower.tail = FALSE), 4), \n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-12-1.png){width=192}\n:::\n:::\n\n\nOr a region of 40% in the middle of the distribution, separating 30% in each tail:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  stat_function(fun = dnorm, geom = \"density\", \n                xlim = c(qnorm(0.3), qnorm(0.3, lower.tail = FALSE)), \n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-13-1.png){width=192}\n:::\n:::\n\n\nYou could even turn this into a convenient function...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_distribution <- function(lower_z = -4, upper_z = 4) {\n  ggplot() +\n  stat_function(fun = dnorm, \n                geom = \"density\", \n                xlim = c(lower_z, upper_z), # xlim goes up to 2\n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n}\n\nplot_distribution(-2, 2)\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-14-1.png){width=192}\n:::\n:::\n\n\nI'm not saying this will make your life easier: you still have to know your way around `pnorm()`, `qnorm()`, and the idea of chopping the distribution into different regions. But it can be satisfying to produce a visual reference corresponding to your numeric answer.\n:::\n::::\n",
    "supporting": [
      "problem-set-4-instructions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}