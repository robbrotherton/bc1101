---
format: revealjs
---

# 8|SAMPLING

::: {#cover-container}
:::

<!-- ![](covers/08_sampling.svg){.invertable} -->

```{r ref.label=I('data')}
```


# Overview

- [Sampling error]
- [Distribution of sample means]
- [Central Limit Theorem]
- [Learning checks]



## Roadmap

- So far...  
  - $z$-scores describe the location of a single score in a sample or in a population
  - Normal distributions: precisely quantify probability of obtaining certain *scores*
- Moving forward...


# Sampling error

## Sampling error

::: {#sample-inference-container}
:::

- Error: Discrepancy between a sample statistic and the population parameter


```{ojs}
import { pop } from "./02_variables.qmd";
```

```{css}
#sample-inference-container {
  height: 70%;
  width: 90%;
  margin-left: 5%
}

#sample-inference-container > svg {
  width: 100%;
  height: 100%;
}

```



## Sampling error

:::: {.columns}

::: {.column width="40%"}
- Discrepancy between a sample statistic and the population parameter
  - E.g. Opinion polling
  - see [Pew explainer](https://www.pewresearch.org/fact-tank/2016/09/08/understanding-the-margin-of-error-in-election-polls/)
:::

::: {.column width="60%"}
![](media/margin-of-error.png)
:::

::::





## Sampling error: IQ

<div data-prevent-swipe>
```{ojs}
viewof quantity = Inputs.range([1, samples.length], {value: 1, step: 1})
```
</div>

::: {#sampling-chart}
:::

::: {#sampling-info}
:::



# Distribution of Sample Means

- "Distribution of Sample Means" / "Sampling distribution of the mean"
  - Distribution of sample means obtained by selecting all possible samples of size $n$ from a population
  - Often huge number of possible samples
  - But distribution forms a simple & predictable pattern

## Characteristics {.smaller}
  - Shape
      - The distribution will be approximately normal
      - Sample $M$s are representative of population $\mu$
      - Most means will be close to $\mu$; means far from $\mu$ are rare
  - Center
      - The center/average of the distribution will be close to $\mu$
      - $M$ is a *unbiased* statistic
      - *On average*, $M = \mu$
  - Variability
      - Related to sample size, $n$
      - The larger the sample, the less the variability 
      - Larger samples are more representative


## Example: height distribution

::: {.r-hstack style="align-items: baseline; padding-left: 1.2em;"}
![](media/person.svg){.invertable height=150px style="margin-right: 1.5em;"}

![](media/person.svg){.invertable height=160px style="margin-right: 1.5em;"}

![](media/person.svg){.invertable height=170px style="margin-right: 1.5em;"}

![](media/person.svg){.invertable height=180px style="margin-left: 1.5em;"}
:::

![](media/stick-histogram.svg){.invertable}

## Example: height distribution

:::: {.columns}

::: {.column width="30%"}
![](media/stick-histogram.svg){.invertable}

```{r stick-table}
#| style: "font-size: 0.5em;line-height: 0.9em;"

knitr::kable(sampling_dist_df)
  
```

:::

::: {.column width="70%"}
Sampling distribution ($n = 2$)

![](media/stick-sampling-distribution.svg){.invertable}

::: {.center-element style="font-size: 0.8em; margin-top: -1em;"}
$p(M < 61) =\ ?$

$p(62 \le M \le 64) =\ ?$

$p(M > 65) =\ ?$
:::

:::

::::


## Example: height distribution {.smaller}

:::: {.columns}

::: {.column width="50%"}
![](media/stick-sampling-distribution.svg){.invertable}

- Now we can calculate variability of sample means
  - Since we obtained every sample mean
  - Use population SD formula
:::

::: {.column width="50%"}
```{r}
#| style: "font-size: 0.8em; line-height: 0.9em;"

bc1101tools::SD_table(sampling_dist_df$M, population_sd = TRUE)
  
```
:::

::::



# Central Limit Theorem

- Sampling & the Central Limit Theorem
  - Distribution of samples means based on all possible samples from a population not feasible in most realistic situations
  - But we can [mathematically predict]{.emph} shape, mean, & variability for any sample size & population

## Central Limit Theorem

- For any population with mean $\mu$ and standard deviation $\sigma$, the distribution of sample means for sample size n will have…
  - An expected mean $\mu_M$ of $\mu$ 
  - A standard deviation of $\dfrac{\sigma} {\sqrt{n}}$ 
  - And will approach a normal distribution as $n$ approaches infinity


## Shape {.small}

- Almost perfectly normal in either of two conditions 
  - The population from which the samples are selected is a normal distribution
  - Or…
  - Sample $n$s are relatively large

::: {.fragment}
- ...what is *relatively large*? 
  - As $n$ approaches infinity, distribution of sample means approaches a normal distribution 
  - But by $n = 30$ means pile up symmetrically around $\mu$
  - Population distribution does not need to be normal; can be skewed, flat, bimodal, whatever
:::

## Mean

- Mean of the distribution of sample means is called the [expected value of $M$ ( $\mu_M$ )]{.emph} 
  - On average, $M = \mu_M  = \mu$
  - $M$ is [unbiased]{.emph}
  - If we only have a single sample $M$, our best guess at the (unknown) population mean should always be the (known) sample mean
  - But we can acknowledge variability...

## Variability

- Standard deviation of the sample means
  - ["Standard error of the mean";  $\sigma_M$]{.emph}
  - Measure of how well a sample mean estimates its population mean
  - How much sampling error we can expect; how much distance is expected on average between $M$ and $\mu$

::: {.center-element}
$\sigma_M = \dfrac{\sigma}{\sqrt{n}}$ or $\dfrac{\sqrt{\sigma^2}}{\sqrt{n}}$ or $\sqrt{\dfrac{\sigma^2}{n}}$
:::

## Variability

![](media/samp-dist-1.png)

## Variability

```{ojs params}
#| echo: false

d3 = require("https://d3js.org/d3.v5.min.js")
jStat = require("https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js")

width = 1000
height = 600

```

```{css}
.n-label input[type="number"] {
  font-family: KaTeX_Main;
  font-size: 1.1em;
  background: none;
  border: none;
  width: fit-content !important;
}

label {
  width: fit-content !important;
}

.n-label div {
  overflow: hidden !important;
}

.n-label {
  position: absolute;
  top: 5em;
}


```

::: {.n-label}

```{ojs n-control}
#| echo: false
#| class: "katex"

viewof mu = Inputs.number({value: 100, label: tex`\mu = `})

viewof sigma = Inputs.number({value: 15, label: tex`\sigma = `})

viewof n = Inputs.range([1, 50], {value: 1, step: 1, label: tex`n = `})
```

```{ojs std-err-label}
tex`\sigma_M = ${std_err.toLocaleString(undefined, {maximumFractionDigits: 2, minimumFractionDigits: 2})}`

```
:::


```{ojs ojs-data}
#| echo: false

std_err = sigma / Math.sqrt(n)



max_std_err = sigma / Math.sqrt(50)

population_curve = {
  var values = jStat(xlim[0], xlim[1], 210)[0],
      arr = [];
  for (var i in values) {
    arr.push({
        value: values[i], 
        density: jStat.normal.pdf(values[i], mu, sigma)
      })
  }
  return arr;
}

curve = {
  var values = jStat(xlim[0], xlim[1], 210)[0],
      arr = [];
  for (var i in values) {
    arr.push({
        value: values[i], 
        density: jStat.normal.pdf(values[i], mu, std_err)
      })
  }
  return arr;
}

```

```{ojs chart}
#| echo: false
#| style: "position: absolute; top: 0;"

chart = {
  const svg = d3.select(DOM.svg(width, height));

  svg.append("g")
      .call(xAxis)
      .attr("transform", `translate(0,${y(0)})`)
      .attr("class", "axis")
      .style("font-size", "0.5em");

  svg.append("path")
      .datum(population_curve)
      .attr("fill", "none")
      .attr("stroke", "black")
      .attr("opacity", 0.5)
      .attr("stroke-width", 1.5)
      .attr("stroke-dasharray", [10, 10])
      .attr("d", line)
      .attr("class", "invertable");
      
  svg.append("path")
      .datum(curve)
      .attr("fill", "none")
      .attr("stroke", "black")
      .attr("stroke-width", 4)
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("d", line)
      .attr("class", "invertable");
      
  return svg.node();
}

```

```{ojs functions}

margin = ({top: 20, right: 0, bottom: 30, left: 0})

xlim = [mu - 3 * sigma, mu + 3 * sigma]

line = d3.line()
    .x(d => x(d.value))
    .y(d => y(d.density))

x = d3.scaleLinear()
  .domain([xlim[0], xlim[1]])
  .range([margin.left, width - margin.right])


y = d3.scaleLinear()
  .domain([0, jStat.normal.pdf(mu, mu, max_std_err)])
  .range([height - margin.bottom, margin.top])
  
xAxis = d3.axisBottom(x).ticks(10)

```


## Variability

![](media/samp-dist-2.png)


## Variability: heights sampling dist

:::: {.columns}

::: {.column width="30%"}
![](media/stick-histogram.svg){.invertable}

```{r}
#| style: "font-size: 0.5em; line-height: 0.9em;"

knitr::kable(sampling_dist_df)
  
```

:::

::: {.column width="70%"}
Sampling distribution ($n = 2$)

![](media/stick-sampling-distribution.svg){.invertable}

::: {.center-element .small}
$\sigma_M = \dfrac{\sigma}{\sqrt{n}} = \dfrac{2.24}{\sqrt{2}} = 1.58$
:::

:::

::::

## Summary

- Summary
  - Distribution of sample means for samples of size $n$ will have...
    - a mean of $\mu_M$
    - standard deviation $\sigma_M = \sigma / \sqrt{n}$
    - Shape will be normal if population is normally distributed, or $n > 30$

# Learning checks {.small}

1. True or False?
    - The mean of a sample is always equal to the population mean
    - The shape of a distribution of sample means is always normal
    - As sample size increases, the value of the standard error always decreases
2. Describe the distribution of sample means (shape, expected value of the mean, and standard error) for samples of $n = 100$ selected from a population with $\mu = 40$ and $\sigma = 10$.



::: {.content-hidden}

# Data and figures

## Cover

```{r cover-ggplot}
#| eval: false

library(gganimate)
library(dplyr)
library(ggforce)

# library(tweenr)
library(gifski)
# library(tidyverse)

set.seed(42)
n_samples <- 3000
data <- rnorm(n_samples, mean = 100, sd = 15) %>% round(0)
df <- data.frame(n = seq_along(data),
                 x = data,
                 y = 1) %>%
  group_by(x) %>%
  mutate(y_cum = cumsum(y))

p <- ggplot(df, aes(x = x, y = y_cum, group = n)) +
  ggforce::geom_regon(aes(x0 = x, y0 = y_cum-.5, sides = 4, r = sqrt((.5^2)*2), angle = 0), color = "white", fill = rgb(.5, .5, .5)) +
  coord_fixed() +
  # transition_reveal(n) +
  theme_void() +
  NULL

ggsave(plot = p,
       filename = here::here("slides", "covers", "08_sampling.svg"),
       width = 10, height = 5)

p_anim <- p +
  transition_reveal(n)

animate(p_anim,
        bg = 'transparent',
        nframes = length(data)/20,
        renderer = av_renderer(),
        fps = 10,
        width = 1200, height = 600)

anim_save(here::here("slides", "media", "08_sampling-animated-cover.mp4"))

```

```{r}
#| eval: false
set.seed(42)
n_samples <- 3000
data <- rnorm(n_samples, mean = 100, sd = 21) %>% round(0)
df <- data.frame(n = seq_along(data),
                 x = data,
                 y = 1) %>%
  group_by(x) %>%
  mutate(y_cum = cumsum(y))

ggplot(df, aes(x = x, y = y_cum, group = n)) +
  ggforce::geom_regon(aes(x0 = x, y0 = y_cum-.5, sides = 4, r = sqrt((.5^2)*1.5), angle = 0), color = NA, fill = rgb(.5, .5, .5)) +
  coord_fixed() +
  # transition_reveal(n) +
  theme_void() +
  NULL

bc1101tools::plot_save("08_sampling.svg", subdir = "covers", width = 10, height = 5)
```

:::

```{r cover-data}

set.seed(42)
n_samples <- 3000
data <- rnorm(n_samples, mean = 100, sd = 21) %>% round(0)
df <- data.frame(n = seq_along(data),
                 xValue = data,
                 yValue = 1) %>%
  group_by(xValue) %>%
  mutate(y_cum = cumsum(yValue)) 

data <- df |> 
  purrr::transpose()

ojs_define(data)

```

```{ojs}

w = 1050
h = 500

xScale = d3.scaleLinear()
  .domain([25, 175])
  .range([0, w])
yScale = d3.scaleLinear()
  .domain([0, 70])
  .range([h, 0])

cover = {

const svg = d3.select("#cover-container")
  .append("svg")
  .attr("width", w).attr("height", h)

svg.selectAll("rect")
  .data(data)
  .enter()
  .append("rect")
    .attr("class", "invertable")
    .attr("x", d => xScale(d.xValue))
    .attr("y", d => yScale(d.y_cum))
    .attr("width", 5)
    .attr("height",5)
    .style("fill", "black")
    .style("stroke", "none")
    .style("opacity", 0)
    .transition().duration(0).delay((d,i) => i*2)
      .style("opacity", 1)

}
```

::: {.content-hidden}
## Sampling IQ
:::




```{r}
#| echo: false
#| message: false

library(dplyr)
set.seed(42)
n_samples <- 500

random_iq <- function(n = 10) rnorm(n, 100, 15) |> round()

observations <- replicate(n_samples, random_iq(), simplify = FALSE)
means <- purrr::map_dbl(observations, mean)

samples <- tibble::tibble(id = 1:n_samples,
                          sample = observations,
                          mean = means,
                          mean_bin = round(mean)) |> 
  group_by(mean_bin) |> 
  mutate(count = 1:n()) |> 
  purrr::transpose()

ojs_define(samples)
```



```{ojs}


sampling_chart = {

  const w = 1050
  const h = 450
  const margin = ({top: 20, right: 200, bottom: 40, left: 200})
  const xlims = [75, 125]
  const xRange = xlims[1] - xlims[0]
  const x = d3.scaleLinear()
    .domain(xlims)
    .range([margin.left, width - margin.right])

  const max_y = Math.max(...samples.map(o => o.count))

  const y = d3.scaleLinear()
    .domain([0, max_y])
    .range([h - margin.bottom, margin.top])

  const xAxis = d3.axisBottom(x).ticks(8)
  const yAxis = d3.axisLeft(y).ticks(3)


  d3.select("#sampling-chart").select("svg").remove()
  
  const svg =  d3.select("#sampling-chart")
    .append("svg").attr("width", w).attr("height", h)

  const g = svg.append("g").attr("id", "boxes")
  
  g.selectAll("rect")
    .data(samples.slice(0, quantity))
    .enter()
    .append("rect")
      .attr("class", "invertable")
      .attr("fill", "black")
      .attr("stroke", "none")
      .attr("x", d => x(d.mean_bin - 0.5))
      .attr("y", d => y(d.count))
      .attr("width", (width-margin.left-margin.right)/xRange * 0.9)
      .attr("height", (h-margin.top-margin.bottom)/max_y * 0.9)
      .each(function (d, i) {
            if (i === quantity-1) {
              // put all your operations on the second element, e.g.
              d3.select(this).attr("fill", "red");    
            }
          });
  svg.append("g").attr("id", "xaxis")
      .call(xAxis)
      .attr("transform", `translate(0,${y(0)})`)
      .attr("class", "axis")
      .style("font-size", "0.5em");
      
  <!-- svg.append("g").attr("id", "yaxis") -->
  <!--     .call(yAxis) -->
  <!--     .attr("transform", `translate(${x(xlims[0])}, 0)`) -->
  <!--     .attr("class", "axis") -->
  <!--     .style("font-size", "0.5em"); -->

}

```


```{ojs}
d = d3.select("#sampling-info")
  .style("font-family", "KaTeX_Main")
  .style("font-size", "0.9em")
  .html("Observations: " + samples[quantity-1].sample.join(", ") + '<br/>' + "<i>M</i> = " + samples[quantity-1].mean)

```





::: {.content-hidden}

## Stick people

```{r data}
library(bc1101tools)
library(dplyr)

stick_heights <- c(60, 62, 64, 66)

sampling_dist_df <- expand.grid(stick_heights, stick_heights) |> 
  rowwise() |>
  mutate(M = mean(c(Var1, Var2))) |> 
  ungroup() |> 
  mutate(Sample = row_number()) |> 
  select(Sample, X1 = Var1, X2 = Var2, M)
```

## Stick distribution

```{r figures}
#| eval: false

library(ggplot2)

plot_histogram(stick_heights, xlab = "Height (inches)") +
  scale_x_continuous(breaks = 60:66) +
  scale_y_continuous(breaks = 0:1, expand = expansion(c(0, .05))) +
  theme_bc1101()

ggsave(here::here("slides", "media", "stick-histogram.svg"),
       width = 6, height = 1.3)

plot_histogram(sampling_dist_df$M, xlab = "Sample Means", block = TRUE) +
  scale_x_continuous(breaks = 60:66) +
  theme_bc1101()

ggsave(here::here("slides", "media", "stick-sampling-distribution.svg"),
       width = 6, height = 4)

```

:::
