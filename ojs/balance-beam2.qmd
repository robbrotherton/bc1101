---
title: "Balance beam"
format: html
toc: false
execute: 
  echo: false
---


```{ojs}
width = 500
height = 500
n_boxes = 50
scale_width = 15
box_size = width / scale_width
beam_height = box_size / 2
radius = box_size

// multiply the deviations lined up at the bottom to fit on the screen
multiplier = 6/n_boxes




chart = {

  function round_position(x) {
    let interval = width / scale_width
    return Math.round(x / interval)*interval
  }

  function rounded_position_index(x) {
    let interval = width / scale_width
    let x0 = Math.round(x / interval)*interval
    return Math.round(x0/(width/scale_width))  
  }
  
  let positions = d3.range(scale_width).map(i => (0))

  function stack_boxes() {
    for (let i = 0; i < box_data.length; i++) {
      box_data[i].level = positions[box_data[i].x0]
      positions[box_data[i].x0]++
    }
  }

  let box_data = d3.range(n_boxes).map(i => ({
      // x: (Math.random() * (width - box_size * 2) + box_size),
      x0: Math.floor(Math.random() *   scale_width),
      y: height/2 - beam_height/2 - radius,
      color: d3.schemeCategory10[i % 10],
      level: 0
      }))

  for (let i = 0; i < box_data.length; i++) box_data[i].x = box_data[i].x0 * box_size
  
  
  let mean = box_data.reduce((total, next) => total + next.x + box_size/2, 0) / box_data.length
  let pivot = mean
  console.log(mean)
  
  box_data = box_data.sort(function(a, b) { return Math.abs(a.x - pivot) - Math.abs(b.x - pivot); })
  for (let i = 0; i < box_data.length; i++) {
    box_data[i].id = i
  }
    
    stack_boxes()
    
    
  const svg = d3.create("svg")
      .attr("viewBox", [0, 0, width, height])
      .attr("stroke-width", 2)

  const x_ = d3.scaleLinear()
    .range([0, width])
    .domain([0, 10])

  const beam_and_boxes = svg.append("g")
  
  // draw the beam
  beam_and_boxes.append("rect")
    .attr("x", 0)
    .attr("y", height/2 - beam_height / 2)
    .attr("width", width)
    .attr("height",  beam_height)
    .attr("rx", 5)
    .attr("fill", "black")

  const boxes = beam_and_boxes.append("g")
  const deviations = beam_and_boxes.append("g")
  const deviations_vertical = deviations.append("g")
  const deviations_horizontal = deviations.append("g")
  const deviations_sum = svg.append("g").attr("transform", `translate(0, ${height/2 + radius * 2})`)
  const deviations_sum_negative = deviations_sum.append("g")
  const deviations_sum_positive = deviations_sum.append("g").attr("transform", `translate(0, 10)`)
  
  
  boxes.selectAll("rect")
    .data(box_data)
    .join("rect")
      .attr("x", d => d.x)
      .attr("y", d => d.y - d.level*box_size)
      .attr("width", box_size)
      .attr("height", box_size)
      <!-- .attr("rx", 3) -->
      .attr("fill", d => d.color)
      .attr("stroke", null)
      .call(d3.drag().on("start", start_dragging_box)
                     .on("drag", dragging_box)
                     .on("end", stop_dragging_box));
  
  // draw a circle at the true mean point
  const circle = beam_and_boxes.append("circle")
    .attr("cx", mean)
    .attr("cy", height/2)
    .attr("r", 5)
    .attr("fill", "red")
    .call(d3.drag()
             .on("start", start_dragging_mean)
             .on("drag", dragging_mean)
             .on("end", stop_dragging_mean))
  
  // draw a triangle at the pivot point
  const triangle = svg.append("polygon")
    .attr("points", [[0, -radius/2], [radius/2, radius/2], [-radius/2, radius/2]])
    .attr("fill", "red")
    .attr("transform", `translate(${pivot}, ${height/2 + radius * 0.75})`)
    .call(d3.drag()
             .on("start", start_dragging_mean)
             .on("drag", dragging_mean)
             .on("end", stop_dragging_mean))
  

  // draw the ground
  svg.append("line")
    .attr("x1", 0).attr("x2", width)
    .attr("y1", height/2 + radius * 1.25).attr("y2", height/2 + radius * 1.25)
    .attr("stroke", "grey")
    
  draw_deviations()
  

  return svg.node();
  
  
  function start_dragging_mean(event, d) {circle.attr("fill", "dodgerblue")}
  
  function stop_dragging_mean(event, d) {circle.attr("fill", "red")}
  
  function dragging_mean(event, d) {
      pivot = event.x
      let angle = Math.min(Math.max((mean - pivot)*0.1, -7), 7)
       
      if (angle > 6) {
        let hypotenuse = width - pivot
        angle = 90 - Math.acos(radius / hypotenuse) * 180/Math.PI
      } else if (angle < -6) {
        let hypotenuse = pivot
        angle = -1 * (90 - Math.acos(radius / hypotenuse) * 180/Math.PI)
      }
      
      triangle.attr("transform", `translate(${pivot}, ${height/2 + radius * 0.75})`)
      beam_and_boxes.attr("transform", `rotate(${angle}, ${pivot}, ${height/2})`)
      draw_deviations()
  }
  
  function start_dragging_box(event, d) {
    d3.select(this).raise().attr("stroke", "black")
    console.log("x:" + d.x + " x0:" + d.x0 + " level:" + d.level)
  }

  function dragging_box(event, d) {
    box_data[d.id].x = event.x
    // box_data[d.id].x0 = round_position(box_data[d.id].x) + box_size/2
    
    let current_position = box_data[d.id].x0
    let current_level = box_data[d.id].level
    let new_position = rounded_position_index(event.x)
    
    if(new_position != current_position) {
      console.log("moved! from " + current_position + " to " + new_position)
      
      // update the box's position
      box_data[d.id].x0 = new_position
      
      // now this box should go on top of the stack for new_position
      box_data[d.id].level = positions[new_position]
      
      // and update the total number of boxes in that position
      positions[new_position]++
      
      // for the old position, reduce the number of boxes by one, and
      // bump down any boxes that had a higher level that this box
      positions[current_position]--
      for (let i = 0; i < box_data.length; i++) {
        if (d.id==i) continue
        if (box_data[i].x0==current_position && box_data[i].level > current_level) {
            box_data[i].level--
            console.log("movin on down")
        } 
      }
    }

    draw_deviations()
  }

  function stop_dragging_box(event, d) {
    d3.select(this).attr("stroke", null)
  }
  
  function draw_deviations() {
    
    mean = box_data.reduce((total, next) => total + next.x + box_size/2, 0) / box_data.length
    
    boxes.selectAll("rect")
      .attr("x", d => d.x0 * box_size)
      .attr("y", d => d.y - d.level*box_size)
    
    circle.attr("cx", mean)
    
    for (let i = 0; i < box_data.length; i++) box_data[i].dev = (box_data[i].x0*box_size + (box_size/2)) - pivot
    <!-- let box_data_ = box_data.sort(function(a, b) { return Math.abs(a.dev) - Math.abs(b.dev); }) -->
    <!-- console.log(box_data_sorted) -->
    
    let deviations_negative = box_data.filter(function(d){ return d.dev < 0})
    for (let i = 0; i < deviations_negative.length; i++) {
      if (i==0) deviations_negative[i].dev_start = 0
      else deviations_negative[i].dev_start = deviations_negative[i-1].dev_end
      deviations_negative[i].dev_end = deviations_negative[i].dev_start + Math.abs(deviations_negative[i].dev)
    }
    
    let deviations_positive = box_data.filter(function(d){ return d.dev > 0})
    for (let i = 0; i < deviations_positive.length; i++) {
      if (i==0) deviations_positive[i].dev_start = 0
      else deviations_positive[i].dev_start = deviations_positive[i-1].dev_end
      deviations_positive[i].dev_end = deviations_positive[i].dev_start + Math.abs(deviations_positive[i].dev)
    }
    
    
    deviations_vertical.selectAll("line")
      .data(box_data)
      .join("line")
        .attr("x1", d => box_size * d.x0 + box_size/2)
        .attr("x2", d => box_size * d.x0 + box_size/2)
        .attr("y1", d => d.y)
        .attr("y2", (d, i) => height/2 - radius*2 - d.id * 20)
        .attr("stroke", "black")
        .attr("stroke-dasharray", [5, 5])

    deviations_horizontal.selectAll("line")
      .data(box_data)
      .join("line")
        .attr("x1", d => box_size * d.x0 + box_size/2)
        .attr("x2", pivot)
        .attr("y1", (d, i) => height/2 - radius*2 - d.id * 20)
        .attr("y2", (d, i) => height/2 - radius*2 - d.id * 20)
        .attr("stroke", d => d.color)
        .attr("stroke-width", 3)
    

    deviations_sum_negative.selectAll("line")
      .data(deviations_negative)
      .join("line")
        .attr("x1", d => d.dev_start * multiplier)
        .attr("x2", d => d.dev_end * multiplier)
        .attr("stroke", d => d.color)
        .attr("stroke-width", 5)
        
    deviations_sum_positive.selectAll("line")
      .data(deviations_positive)
      .join("line")
        .attr("x1", d => d.dev_start * multiplier)
        .attr("x2", d => d.dev_end * multiplier)
        .attr("stroke", d => d.color)
        .attr("stroke-width", 5)
  }
  


  
}
```


```{ojs}
<!-- drag = { -->

<!--   function dragstarted(event, d) { -->
<!--     d3.select(this).raise().attr("stroke", "black") -->
<!--     console.log(d.id) -->
<!--   } -->

<!--   function dragged(event, d) { -->
<!--     d3.select(this).attr("x", event.x) -->
<!--   } -->

<!--   function dragended(event, d) { -->
<!--     d3.select(this).attr("stroke", null); -->
<!--   } -->

<!--   return d3.drag() -->
<!--       .on("start", dragstarted) -->
<!--       .on("drag", dragged) -->
<!--       .on("end", dragended); -->
<!-- } -->


drag_pivot = {

  function dragstarted(event, d) {
    d3.select(this).raise().attr("stroke", "red");
  }

  function dragged(event, d) {
    d3.select(this).attr("cx", event.x)
  }

  function dragended(event, d) {
    d3.select(this).attr("stroke", null);
  }

  return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
}



```
