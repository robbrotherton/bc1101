---
title: "(Un)Biased estimates"
format: html
toc: false
execute: 
  echo: false
---

::: {style="display: flex;"}
::: {#controls-container style="width: 50%;"}
:::

::: {#select-estimate style="width: 50%;"}
Show: 
[$M$]{.select-mean .selector .unselected}
[$SD_{n}$]{.select-population .selector}
[$SD_{n - 1}$]{.select-sample .selector}
:::
:::

::: {#population-container style="float: left; width: 50%;"}
:::

::: {#estimates-container style="float: right; width: 50%;"}
:::

::: {#timeline-container style="display: block; width: 100%;"}
:::

```{ojs}
jStat = require("https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js")
```

```{r}
data <- tibble::tibble(value = seq(-4, 4, length.out = 201),
                       density = dnorm(value)) |> 
  purrr::transpose()

ojs_define(data)

set.seed(4)
population <- rnorm(550)
population <- scale(population)
# sd(population) # should be 1
ojs_define(population)
```


```{ojs}
w = 800
h = 400
curveWidth = 500

radius = 5; //1.4


    
xScalePopulation = d3.scaleLinear()
    .domain([Math.min(...population), Math.max(...population)])
    .range([0 + radius, (w * 0.5) - radius])
yScalePopulation = d3.scaleLinear()
    .domain([0, 300])
    .range([h, 0])

xScaleEstimates = d3.scaleLinear()
    .domain([-1, 1])
    .range([w * 0.05, w * 0.4])
yScaleEstimates = d3.scaleLinear()
    .domain([20, 0])
    .range([h - 50, 60])

```




```{ojs}
update_svg = {

  var sample = [];
  var sampleData = [];
  var sample_estimates = [];
  var running_averages = [{param: "population", value: [0], id: [0]},
                          {param: "sample",     value: [0], id: [0]},
                          {param: "mean",       value: [0], id: [0]}];
  
  var nSamplesDrawn = 0;
  
  var legendSelected = ["sample", "population"]
  
  var biasY = d3.scaleLinear()
    .range([h-100, 100])
    
  
  
  
  function newSample() {
    
    nSamplesDrawn++
    
    // pick random observations from the population by their index
    for (var i = 0; i < 10; i++) {
      let randomIndex = Math.floor(Math.random() * popData.length);
      sample[i] = xScalePopulation.invert(popData[randomIndex].cx);
      sampleData[i] = popData[randomIndex];
    }
    
    var estimates = getSampleEstimates(sample)
    estimates.map(d => d.id = nSamplesDrawn);
    sample_estimates.push(estimates)
    
    updateRunningAverages(estimates);
    updateBiasChart();
    updateSampleCircles();
    updatePath();
    updateVisibility();
  }
  
  function updateBiasChart() {
      yScaleEstimates.domain([nSamplesDrawn-20, nSamplesDrawn])
      
      biasDots.selectAll("path").remove()
      biasDots.selectAll("path")
          .data(sample_estimates.flat().slice(-210))
          .enter()
          .append("path")
            .attr("id", d => d.param + "-estimate")
            .attr("d", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))
            .attr("transform", d => `translate(${xScaleEstimates(d.value)}, ${yScaleEstimates(d.id + 1)}) rotate(45)`)
            .transition()
            .attr("transform", d => `translate(${xScaleEstimates(d.value)}, ${yScaleEstimates(d.id)}) rotate(45)`)
            
  }
  

  function updatePath() {
      biasPaths.selectAll("g").remove()
      
      if (nSamplesDrawn > 201) {
        timeX.domain([nSamplesDrawn - 200, nSamplesDrawn]);
        timeXAxis = d3.axisBottom(timeX).tickSize(0);
        timeChartXAxis.call(timeXAxis);
        timeChartXAxis.select(".domain").remove();
      }
      
      biasPaths.selectAll("g")
        .data(running_averages)
        .enter()
        .append("g")
        .attr("class", "bias-paths")
        .append("path")
          .attr("d", d => biasLine(d.id.slice(1), d.value.slice(1)))
          .attr("id", d => d.param + "-path")

  }
  
  function updateSampleCircles() {
  
  let durationMultiplier = 5;
  if (playing) durationMultiplier = 1;
  
    sampleCircles.selectAll('circle').remove()
    sampleCircles.selectAll('circle')
      .data(sampleData)
      .enter().append("circle")
      .attr("class", "sample")
      .attr("r", radius)
      .attr("cx", d => d.cx)
      .attr("cy", d => (h - 50) - d.cy)
      .attr("fill", d => d.fill)
      .transition()
      .duration(d => d.cy * durationMultiplier)
      .ease(d3.easeBounceOut)
      .attr("cy", h - 10)
  }
  
  const sleep = (milliseconds) => {
    return new Promise(resolve => setTimeout(resolve, milliseconds))
  }
  var playing = false;
  function playButtonClicked() {
    
    playing = !playing; 
    console.log(playing);
  
  play_button.text(function(){
    if(playing) {
      return "◼"
  } else {
    return "▶"
  }
  })
  
  if (playing) {
    continuouslyDrawSamples();
  }
  }
  
  function continuouslyDrawSamples() {
    if (playing) {
      newSample();
      sleep(200).then(continuouslyDrawSamples);
    }
  }
  
    
  var popData = [];
  const color = d3.scaleOrdinal(d3.schemeCategory10);
  for (let i = 0; i < population.length; ++i) {
    const cx = xScalePopulation(population[i]);
    const cy = 20 + (dodge(cx) - radius - 1);
    <!-- const cy = yScalePopulation(dodge(cx)); -->
    const fill = color(i % 10);
    popData.push({cx, cy, fill})
  }
  

  const populationAndSampleSvg = d3.select("#population-container")
    .append("svg").attr("id", "populationAndSample-svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 " + (w * 0.5) + " " + h)
  populationAndSampleSvg.append("rect")
    .attr("width", w * 0.5)
    .attr("height", h - 55)
    .attr("fill", "#c3ddff")
    .attr("rx", 5)
  populationAndSampleSvg.append("rect")
    .attr("width", w * 0.5)
    .attr("y", h - 50)
    .attr("height", 50)
    .attr("fill", "#d3d8a8")
    .attr("rx", 5)
  populationAndSampleSvg.append("text")
    .text("Population")
    .attr("y", 20)
  populationAndSampleSvg.append("text")
    .text("Sample")
    .attr("y", h - 30)
    
    
  const estimatesSvg = d3.select("#estimates-container")
    .append("svg").attr("id", "estimates-svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 " + (w * 0.5) + " " + h)
  
  estimatesSvg.append("text")
    .text("Over/Under estimation of parameter")
    .attr("y", 20)
    
  const pop = populationAndSampleSvg.append("g")
  const sampleCircles = populationAndSampleSvg.append("g")
  
  const biasChart = estimatesSvg.append("g")
  const biasDots  = estimatesSvg.append("g")
  
  
  pop.selectAll("circle")
      .data(popData)
      .enter()
      .append("circle")
        .attr("class", "pop")
        .attr("cx", d => d.cx)
        .attr("cy", d => (h - 50) - d.cy)
        .attr("r", radius)
        .attr("fill", d => d.fill)
      
  const sdAxis = estimatesSvg.append("g").attr("class", "axis invertable")
  const axisLabels = [-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75]
  sdAxis.selectAll("line")
    .data(axisLabels)
    .enter().append("line")
      .attr("class", function(d,i){
        if(i==3) {return "axis-major"} else {return "axis-minor"}
      })
      .attr("x1", d => xScaleEstimates(d))
      .attr("x2", d => xScaleEstimates(d))
      .attr("y1", yScaleEstimates(0))
      .attr("y2", yScaleEstimates(23))
  sdAxis.selectAll("text").data(axisLabels).enter().append("text")
      .text(d => d)
      .attr("x", d => xScaleEstimates(d))
      .attr("y", yScaleEstimates(-1))
      .attr("text-anchor", "middle")

    
  var legendStatus = [{param: "mean",       hide: true},
                      {param: "population", hide: false},
                      {param: "sample",     hide: false}]
                      
  
  function updateLegendStatus(param) {
  console.log(param);
    var index;
    if (param==="mean") {index = 0;}
    if (param==="population") {index = 1;}
    if (param==="sample") {index = 2;}
    legendStatus[index].hide = !legendStatus[index].hide

  console.log(legendStatus[index])
  
    <!-- d3.select("#select" + param) -->
    <!--   .attr(") -->
  
    var classes = "#" + param + "-estimate"
    
    estimatesSvg.selectAll(classes).classed("hide", legendStatus[index].hide)
    timeSvg.selectAll("#" + param + "-path").classed("hide", legendStatus[index].hide)
    legend.classed("unselected", d => d.hide)
  }
  
    const legend = d3.selectAll(".selector")
    console.log(legend)
    legend
      .data(legendStatus)
      .classed("unselected", d => d.hide)
      .on("click", function(event, d){updateLegendStatus(d.param);})
  


  
  // buttons
  const controls = d3.select("#controls-container")
  
  const reset_button = controls.append("text")
  .attr("class", "button invertable")
    .html("&#x21bb;")
    .attr("x", 10)
    .attr("y", h - 50)
    .on("click", clearData)
  
  const button = controls.append("text")
  .attr("class", "button invertable")
    .text("ᐳ")
    .attr("x", 30)
    .attr("y", h - 50)
    .on("click", newSample)
    
  const play_button = controls.append("text").attr("id", "play-button")
  .attr("class", "button invertable")
    .attr("x", 50)
    .attr("y", h - 50)
    .html("►")
    .on("click", playButtonClicked)
    

  
  const timeChart = {
    width: 800,
    height: 300,
    margin: {left: 30, right: 30, top: 40, bottom: 40}
  }
  
  
  var timeX = d3.scaleLinear()
    .domain([0, 200])
    .range([timeChart.margin.left, timeChart.width - timeChart.margin.right])
    .clamp(true);
  const timeY = d3.scaleLinear()
    .domain([-0.5, 0.5])
    .range([timeChart.height - timeChart.margin.bottom, timeChart.margin.top])
  const biasLine = function(x, y){
      return d3.line()
      .x(function(d,i) { return timeX(x[i]); }) 
      .y(function(d,i) { return timeY(y[i]); })
      (Array(x.length));
  }
  
  var timeXAxis = d3.axisBottom(timeX).tickSize(0)
  const timeYAxis = d3.axisLeft(timeY).ticks(5).tickSize(0)
  
  const timeSvg =   d3.select("#timeline-container")
    .append("svg").attr("id", "timeline-svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 800 300")
  timeSvg.append("rect")
    .attr("width", timeChart.width)
    .attr("height", timeChart.height)
    .attr("rx", 5)
    .attr("fill", "#eee")
  timeSvg.append("text")
    .attr("y", 20)
    .text("Average under/over-estimation by number of samples taken")

  timeSvg.append("g")
      .selectAll("line")
      .data([-0.4, -0.2, 0, 0.2, 0.4])
      .enter().append("line")
        .attr("x1", d => timeX(0)).attr("x2", d => timeX(500))
        .attr("y1", d => timeY(d)).attr("y2", d => timeY(d))
        .attr("class", function(d){if(d===0){return"axis-major"}else{return "axis-minor"}})
    
  const timeChartXAxis = timeSvg.append("g")
  timeChartXAxis.attr("transform", `translate(0, ${timeY(-0.5)})`)
  timeChartXAxis.call(timeXAxis);
  timeChartXAxis.select(".domain").remove();
  

  
  timeChartXAxis.append("text")
    .attr("fill", "var(--text-color")
    .attr("x", timeX(0)).attr("y", 30)
    .attr("font-size", "1.5em")
    .attr("text-anchor", "start")
    .text("Number of samples taken")
  
  const biasPaths = timeSvg.append("g")
  
  const timeChartYAxis = timeSvg.append("g")
  timeChartYAxis.attr("transform", `translate(${timeChart.margin.left}, 0)`)
  timeChartYAxis.call(timeYAxis)
  


function clearData() {
    sample = [];
    sample_estimates = [];
    running_averages = [{param: "population",   value: [0], id: [0]},
                          {param: "sample",     value: [0], id: [0]},
                          {param: "mean",       value: [0], id: [0]}];
    nSamplesDrawn = 0;
    
    sampleCircles.selectAll('circle').remove()
    biasDots.selectAll("circle").remove()
    biasPaths.selectAll("path").remove()
  }
  
  function updateRunningAverages(estimates) {
  
      var cur_n = nSamplesDrawn
      var prev_n = cur_n - 1
      
      var old = running_averages[0].value[prev_n]
      var new_pop = ((old * prev_n) + estimates[0].value)/cur_n
      running_averages[0].value.push(new_pop)
      
      var old = running_averages[1].value[prev_n]
      var new_sam = ((old * prev_n) + estimates[1].value)/cur_n
      running_averages[1].value.push(new_sam)
      
      var old = running_averages[2].value[prev_n]
      var new_mea = ((old * prev_n) + estimates[2].value)/cur_n
      running_averages[2].value.push(new_mea)
    
      running_averages[0].id.push(cur_n)
      running_averages[1].id.push(cur_n)
      running_averages[2].id.push(cur_n)

}

  function updateVisibility() {
  
    var params = ["mean", "population", "sample"]
    
    for (var i = 0; i < 3; i++) {
      var param = params[i]
      var elementIds = "#" + param + "-estimate, #" + param + "-line"
      
      estimatesSvg.selectAll(elementIds).classed("hide", legendStatus[i].hide)
      timeSvg.selectAll("#" + param + "-path").classed("hide", legendStatus[i].hide)
    }
  }
  
}

```

:::{.content-hidden}
# Helper functions
:::

```{ojs}

dodger = radius => {
  const radius2 = radius ** 1.8;
  const bisect = d3.bisector(d => d.x);
  const circles = [];
  return x => {
    const l = bisect.left(circles, x - radius);
    const r = bisect.right(circles, x + radius, l);
    let y = 0;
    for (let i = l; i < r; ++i) {
      const { x: xi, y: yi } = circles[i];
      const x2 = (xi - x) ** 2;
      const y2 = (yi - y) ** 2;
      if (radius2 > x2 + y2) {
        y = yi + Math.sqrt(radius2 - x2) + 1e-6;
        i = l - 1;
        continue;
      }
    }
    circles.splice(bisect.left(circles, x, l, r), 0, { x, y });
    return y;
  };
}

dodge = dodger(radius * 2 + 1);
```

```{ojs}

function mean(array) {
    return array.reduce((a, b) => a + b) / array.length;
}

function sample_variance(array) {
    const n = array.length
    const m = mean(array)
    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / (n - 1);
}

function population_variance(array) {
    const n = array.length
    const m = mean(array)
    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / n;
}

function get_descriptives (array) {
    return {mean: mean(array),
            sample_variance: sample_variance(array) - 1, 
            population_variance: population_variance(array) - 1}
}

function getNewData (array) {
    
    return {sample_estimates: getSampleEstimates(array)
            <!-- running_averages: getRunningAverages(array) -->
            }
}

function getSampleEstimates(array) {
    return [{param: "population", value: population_variance(array) - 1},
            {param: "sample",     value: sample_variance(array) - 1},
            {param: "mean",       value: mean(array)}]
}

```

::: {.content-hidden}
# CSS
:::

```{css}

:root {
  --population-color: pink;
  --sample-color: var(--link-color);
  --mean-color: purple;
}

.axis {
  font-size: 0.75em;
}
.bias-chart-title {
  font-size: 1.2em;
}
.axis-major {
  stroke: #aaa;
  stroke-width: 1;
}
.axis-minor {
  stroke: #ddd;
  stroke-width: 1;
}

<!-- .pop, .sample { -->
<!--   fill: lightblue; -->
<!-- } -->
<!-- .pop { -->
<!--   stroke: lightblue; -->
<!-- } -->
<!-- .sample { -->
<!--   stroke: white; -->
<!-- } -->

#sample-estimate, #sample-line, #sample-legend {
  fill: var(--sample-color);
  stroke: var(--sample-color);
}

#mean-estimate, #mean-line, #mean-legend {
  fill:   var(--mean-color);
  stroke: var(--mean-color);
}

#population-estimate, #population-line, #population-legend {
  fill:   var(--population-color);
  stroke: var(--population-color);
}

.legend-unselected {
  fill-opacity: 0.1 !important;
}


.bias-paths {
  fill: none;
  stroke-width: 2;
}

#mean-path {
  stroke: var(--mean-color);
}
#sample-path {
  stroke: var(--sample-color);
}
#population-path {
  stroke: var(--population-color);
}

.hide {
  fill: none !important;
  stroke: none !important;
}


.button {
   font-family: Times;
}
.button:hover {
  fill: red;
  cursor: pointer;
}


.legend-dots:hover {
  cursor: pointer;
}


.selector {
  margin-right: 2em;
  cursor: pointer;
}
.selector::after {
  content: "";
  display: inline-block;
  width: 10px;
  height: 10px;
  transform: translate(50%, -10%) rotate(45deg);
}

.select-mean::after {
  background-color: var(--mean-color);
  border: 1px solid var(--mean-color);
}
.select-mean::after .unselected {
  background-color: "black";
  border: 1px solid var(--mean-color);
}
.select-population::after {
  background-color: var(--population-color);
  border: 1px solid var(--population-color);
}
.select-sample::after {
  background-color: var(--sample-color);
  border: 1px solid var(--sample-color);
}

.unselected::after {
  opacity: 0.2;
}

.unselected:hover::after {
  opacity: 0.5;
}

```

