---
title: "(Un)Biased estimates"
format: 
  html:
    page-layout: full
toc: false
execute: 
  echo: false
---


::: {#controls-container}
:::

::: {#select-estimate}
Show: 
[$M$]{.select-mean .selector .unselected}
[$SD_{n}$]{.select-population .selector}
[$SD_{n - 1}$]{.select-sample .selector}
:::


::: {.g-row}

::: {#population-container}
:::

::: {#timeline-container}
:::

:::

::: {.g-row}
<!-- ::: {#timeline-container style="width: 40%;"} -->
<!-- ::: -->
:::

```{ojs}
jStat = require("https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js")
```

```{r}
data <- tibble::tibble(value = seq(-4, 4, length.out = 201),
                       density = dnorm(value)) |> 
  purrr::transpose()

ojs_define(data)

set.seed(4)
population <- rnorm(550)
population <- scale(population)
# sd(population) # should be 1
ojs_define(population)
```


```{ojs}
w = 800
h = 400

maxWidth = 900;
maxHeight = 550;

populationPanelWidth = maxWidth * 0.6;
populationPanelHeight = maxHeight;

populationSubPanelProportion = 0.4;
sampleSubPanelProportion = 0.05;

estimatesSubPanelProportion = 0.55;

estimatesPanelWidth = maxWidth - populationPanelWidth;
estimatesPanelHeight = populationPanelHeight;

timeSeriesPanelWidth = maxWidth - populationPanelWidth;


radius = 4; //1.4
sampleSize = 5;

    
xScalePopulation = d3.scaleLinear()
    .domain([-4, 4])
    .range([0 + radius, (populationPanelWidth) - radius])
yScalePopulation = d3.scaleLinear()
    .domain([0, 300])
    .range([populationPanelHeight * populationSubPanelProportion, 0])

xScaleEstimates = d3.scaleLinear()
    .domain([-1.25, 1.25])
    .range([0, estimatesPanelWidth])
    
yScaleEstimates = d3.scaleLinear()
    .domain([20, 0])
    .range([maxHeight - 30, maxHeight * (1 - estimatesSubPanelProportion) + 30])

xAxisEstimatesValues = [-2, -1, 0, 1, 2];
xAxisEstimates = d3.axisBottom(xScalePopulation)
  .tickValues(xAxisEstimatesValues)
  .tickFormat(d => d)
  .tickSize(-maxHeight * (1 - estimatesSubPanelProportion) - 10)
    
yPlacementEstimatesSubPanel = d3.scaleLinear()
  .domain([0, 2])
  .range([50 + populationPanelHeight * (1 - estimatesSubPanelProportion), populationPanelHeight - 10])
    
    
```




```{ojs}
update_svg = {

  var sample = [];
  var sampleData = [];
  var sample_estimates = [];
  var running_averages = [{param: "population", value: [0], id: [0]},
                          {param: "sample",     value: [0], id: [0]},
                          {param: "mean",       value: [0], id: [0]}];
  
  var nSamplesDrawn = 0;
  
  var legendSelected = ["sample", "population"]
  
  var biasY = d3.scaleLinear()
    .range([h-100, 100])
    
  
  <!-- var estimates; -->
  
  function newSample() {
    
    nSamplesDrawn++
    
    // pick random observations from the population by their index
    for (var i = 0; i < sampleSize; i++) {
      let randomIndex = Math.floor(Math.random() * popData.length);
      sample[i] = xScalePopulation.invert(popData[randomIndex].cx);
      sampleData[i] = popData[randomIndex];
    }
    
    var estimates = getSampleEstimates(sample)
    estimates.map(d => d.id = nSamplesDrawn);
    sample_estimates.push(estimates)
    
    updateRunningAverages(estimates);
    updateBiasChart();
    updateSampleCircles();
    animateEstimates(sampleData, estimates);
    updatePath();
    updateVisibility();
  }
  
  function updateBiasChart() {
      yScaleEstimates.domain([nSamplesDrawn-20, nSamplesDrawn])
      
      biasDots.selectAll("path").remove()
      biasDots.selectAll("path")
          .data(sample_estimates.flat())
          .enter()
          .append("path")
            .attr("id", d => d.param + "-estimate")
            .attr("d", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))
            .attr("transform", d => `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id + 1)}) rotate(45)`)
            .attr("opacity", d => (d.id === nSamplesDrawn ? 0 : 1))
            .transition()
            .attr("transform", d => `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id)}) rotate(45)`)
            
  }
  

  function updatePath() {
      biasPaths.selectAll("g").remove()
      
      if (nSamplesDrawn > 201) {
        timeY.domain([nSamplesDrawn - 200, nSamplesDrawn]);
        timeYAxis = d3.axisRight(timeY).tickSize(0);
        timeChartYAxis.call(timeYAxis);
        timeChartYAxis.select(".domain").remove();
      }
      
      biasPaths.selectAll("g")
        .data(running_averages)
        .enter()
        .append("g")
        .attr("class", "bias-paths")
        .append("path")
          .attr("d", d => biasLine(d.value.slice(1), d.id.slice(1)))
          .attr("id", d => d.param + "-path")

  }
  
  function updateSampleCircles() {
  
  let durationMultiplier = 5;
  if (playing) durationMultiplier = 1;
  
    sampleCircles.selectAll('circle').remove()
    sampleCircles.selectAll('circle')
      .data(sampleData)
      .enter().append("circle")
      .attr("class", "sample")
      .attr("r", radius)
      .attr("cx", d => d.cx)
      .attr("cy", d => yScalePopulation(d.cy))
      .attr("fill", d => d.fill)
      .transition()
      .duration(d => d.cy * durationMultiplier)
      .ease(d3.easeBounceOut)
      .attr("cy", populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius)
  }
  
  
  
  function animateEstimates(sampleData, estimates) {
  
    sampleEstimatesTemp.selectAll("path").remove()
    
    var wait = Math.max(...sampleData.map(z => z.cy));
    console.log(wait);
    
    for (let i = 0; i < estimates.length; i++) {

    var p = estimates[i].param;
    var endPosition = estimates[i].value;
    var dur = (playing ? 0 : 1000);
    var convergeWait = (playing ? 0 : wait * 5);
    var moveDownWait = (playing ? 250 : 0);
    
    sampleData.forEach((s) => {
    
    // first, place estimate symbols where each sample dot lands
      sampleEstimatesTemp
      .append("path")
      .attr("id", p + "-estimate")
      .attr("d", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))
        .attr("transform", d => `translate(${s.cx}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)
        .attr("opacity", 0)
        
    // then move them all to the estimate
        .transition().duration(dur * 0.67).delay(convergeWait)
        .attr("opacity", 1)
        .attr("transform", d => `translate(${xScalePopulation(endPosition)}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)
        
    // then move them down to the estimates tracker
    .transition().duration((playing ? 250 : (dur * 0.33))).delay(0)
      .ease(d3.easeCubicOut)
        .attr("opacity", 1)
        .attr("transform", `translate(${xScalePopulation(endPosition)}, ${yScaleEstimates(nSamplesDrawn)}) rotate(45)`)
    })

    }
  }
  
  const sleep = (milliseconds) => {
    return new Promise(resolve => setTimeout(resolve, milliseconds))
  }
  var playing = false;
  function playButtonClicked() {
    
    playing = !playing; 
    console.log(playing);
  
  play_button.text(function(){
    if(playing) {
      return "◼"
  } else {
    return "▶"
  }
  })
  
  if (playing) {
    continuouslyDrawSamples();
  }
  }
  
  function continuouslyDrawSamples() {
    if (playing) {
      newSample();
      sleep(200).then(continuouslyDrawSamples);
    }
  }
  
    
  var popData = [];
  const color = d3.scaleOrdinal(d3.schemeCategory10);
  for (let i = 0; i < population.length; ++i) {
    const cx = xScalePopulation(population[i]);
    const cy = 10 + (dodge(cx) - radius - 1);
    <!-- const cy = yScalePopulation(dodge(cx)); -->
    const fill = color(i % 10);
    popData.push({cx, cy, fill})
  }
  
  
  
  const populationLabels = [{label: "Population", top: 0},
                            {label: "Sample",     top: populationSubPanelProportion * 100},
                            {label: "Under/over-</br>estimation of</br>parameter",     top: (populationSubPanelProportion + sampleSubPanelProportion) * 100}]
  
  const populationContainer = d3.select("#population-container")
    .style("position", "relative")
    .style("height", maxHeight)
    
  populationContainer.selectAll("text").data(populationLabels).enter()
    .append("text")
    .style("position", "absolute")
    .html(d => d.label)
    .style("top", d => d.top + "%")
    .style("line-height", "1em")

  const populationAndSampleSvg = d3.select("#population-container")
    .append("svg").attr("id", "populationAndSample-svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 " + populationPanelWidth + " " + populationPanelHeight)
  populationAndSampleSvg.append("rect")
    .attr("width", populationPanelWidth)
    .attr("height", populationPanelHeight * populationSubPanelProportion)
    .attr("fill", "#c3ddff")
    .attr("rx", 5)
  populationAndSampleSvg.append("rect")
    .attr("width", populationPanelWidth)
    .attr("y", populationPanelHeight * populationSubPanelProportion)
    .attr("height", populationPanelHeight * sampleSubPanelProportion)
    .attr("fill", "#d3d8a8")
    .attr("rx", 5)
    
    
  const estimatesSvg = d3.select("#estimates-container")
    .append("svg").attr("id", "estimates-svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 " + estimatesPanelWidth + " " + estimatesPanelHeight)
  
  estimatesSvg.append("text")
    .text("Over/Under estimation of parameter")
    .attr("y", 20)
    
  const pop = populationAndSampleSvg.append("g")
  const parameters = populationAndSampleSvg.append("g")
  const sampleEstimates = populationAndSampleSvg.append("g")
  const sampleEstimatesTemp = populationAndSampleSvg.append("g")
  const sampleCircles = populationAndSampleSvg.append("g")


  const biasChart = estimatesSvg.append("g")
  const biasDots  = sampleEstimates.append("g")
  
  pop.selectAll("circle")
      .data(popData)
      .enter()
      .append("circle")
        .attr("class", "pop")
        .attr("cx", d => d.cx)
        .attr("cy", d => yScalePopulation(d.cy))
        .attr("r", radius)
        .attr("fill", d => d.fill)
        
    // estimates axis
    
  const estimatesAxis = sampleEstimates.append("g")
    .attr("transform", `translate(0, ${yScaleEstimates(21)})`)
  
  estimatesAxis.append("rect")
    .attr("width", populationPanelWidth)
    .attr("height", 100)
    .attr("fill", "var(--background-color)")
  estimatesAxis.call(xAxisEstimates)
  estimatesAxis.select(".domain").remove()
  
  <!-- const sdAxis = sampleEstimates.append("g").attr("class", "axis invertable") -->
  <!-- const axisLabels = [-1, -0.5, 0, 0.5, 1] -->
  <!-- sdAxis.selectAll("line") -->
  <!--   .data(axisLabels) -->
  <!--   .enter().append("line") -->
  <!--     .attr("class", function(d,i){ -->
  <!--       if(d === 0) {return "axis-major"} else {return "axis-minor"} -->
  <!--     }) -->
  <!--     .attr("x1", d => xScalePopulation(d)) -->
  <!--     .attr("x2", d => xScalePopulation(d)) -->
  <!--     .attr("y1", yScaleEstimates(0)) -->
  <!--     .attr("y2", yScaleEstimates(20)) -->
  <!-- sdAxis.selectAll("text").data(axisLabels).enter().append("text") -->
  <!--     .text(d => d) -->
  <!--     .attr("x", d => xScalePopulation(d)) -->
  <!--     .attr("y", yScaleEstimates(21)) -->
  <!--     .attr("text-anchor", "middle") -->

    
  var legendStatus = [{param: "mean",       hide: true},
                      {param: "population", hide: false},
                      {param: "sample",     hide: false}]
                      
  
  function updateLegendStatus(param) {
  console.log(param);
    var index;
    if (param==="mean") {index = 0;}
    if (param==="population") {index = 1;}
    if (param==="sample") {index = 2;}
    legendStatus[index].hide = !legendStatus[index].hide

    var classes = "#" + param + "-estimate"
    
    populationAndSampleSvg.selectAll(classes).classed("hide", legendStatus[index].hide)
    timeSvg.selectAll("#" + param + "-path").classed("hide", legendStatus[index].hide)
    legend.classed("unselected", d => d.hide)
  }
  
    const legend = d3.selectAll(".selector")
    console.log(legend)
    legend
      .data(legendStatus)
      .classed("unselected", d => d.hide)
      .on("click", function(event, d){updateLegendStatus(d.param);})
  


  
  // buttons
  const controls = d3.select("#controls-container")
  
  const reset_button = controls.append("text")
  .attr("class", "button invertable")
    .html("&#x21bb;")
    .attr("x", 10)
    .attr("y", h - 50)
    .on("click", clearData)
  
  const button = controls.append("text")
  .attr("class", "button invertable")
    .text("ᐳ")
    .attr("x", 30)
    .attr("y", h - 50)
    .on("click", newSample)
    
  const play_button = controls.append("text").attr("id", "play-button")
  .attr("class", "button invertable")
    .attr("x", 50)
    .attr("y", h - 50)
    .html("►")
    .on("click", playButtonClicked)
    
// make timeseries chart
const timeChart = {
    width: timeSeriesPanelWidth,
    height: maxHeight,
    margin: {left: 30, right: 30, top: 50, bottom: 60}
}
  
  
var timeX = d3.scaleLinear()
    .domain([-0.5, 0.5])
    .range([timeChart.margin.left, timeChart.width - timeChart.margin.right])
var timeY = d3.scaleLinear()
    .domain([0, 200])
    .range([timeChart.margin.top, timeChart.height - timeChart.margin.bottom])
const biasLine = function(x, y){
      return d3.line()
      .x(function(d,i) { return timeX(x[i]); }) 
      .y(function(d,i) { return timeY(y[i]); })
      (Array(x.length));
  }
  
var timeXAxis = d3.axisTop(timeX).ticks(5).tickSize(0)
var timeYAxis = d3.axisRight(timeY).tickSize(0)
  
  const timeseriesContainer = d3.select("#timeline-container");
  timeseriesContainer.style("position", "relative")

  const timeSvg =   d3.select("#timeline-container")
    .append("svg").attr("id", "timeline-svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 " + timeChart.width + " " + timeChart.height)
  timeSvg.append("rect")
    .attr("width", timeChart.width)
    .attr("height", timeChart.height)
    .attr("rx", 5)
    .attr("fill", "#eee")


  timeSvg.append("g")
      .selectAll("line")
      .data([-0.4, -0.2, 0, 0.2, 0.4])
      .enter().append("line")
        .attr("y1", d => timeY(0)).attr("y2", d => timeY(200))
        .attr("x1", d => timeX(d)).attr("x2", d => timeX(d))
        .attr("class", function(d){if(d===0){return"axis-major"}else{return "axis-minor"}})
    
  const timeChartXAxis = timeSvg.append("g")
  timeChartXAxis.attr("transform", `translate(0, ${timeY(0)})`)
  timeChartXAxis.call(timeXAxis);
  

  
  timeseriesContainer.append("text")
    .style("position", "absolute")
    .style("left", 0)
    .text("Average under/over-estimation")
  
  timeseriesContainer.append("text")
    .style("position", "absolute")
    .style("line-height", "1em")
    .style("bottom", 0)
    .style("right", 0)
    .style("text-align", "right")
    .html("Total<br>samples")
    

  const biasPaths = timeSvg.append("g")
  
  const timeChartYAxis = timeSvg.append("g")
  timeChartYAxis.attr("transform", `translate(${timeChart.width - timeChart.margin.right}, 0)`)
  timeChartYAxis.call(timeYAxis)
  timeChartYAxis.select(".domain").remove();
  timeChartXAxis.select(".domain").remove();
  


function clearData() {
    sample = [];
    sample_estimates = [];
    running_averages = [{param: "population",   value: [0], id: [0]},
                          {param: "sample",     value: [0], id: [0]},
                          {param: "mean",       value: [0], id: [0]}];
    nSamplesDrawn = 0;
    
    timeY.domain([0, 200]);
    timeChartYAxis.call(timeYAxis);
    timeChartYAxis.select(".domain").remove();
    
    sampleCircles.selectAll('circle').remove()
    sampleEstimates.selectAll("path").remove()
    biasPaths.selectAll("path").remove()
  }
  
  function updateRunningAverages(estimates) {
  
      var cur_n = nSamplesDrawn
      var prev_n = cur_n - 1
      
      var old = running_averages[0].value[prev_n]
      var new_pop = ((old * prev_n) + estimates[0].value)/cur_n
      running_averages[0].value.push(new_pop)
      
      var old = running_averages[1].value[prev_n]
      var new_sam = ((old * prev_n) + estimates[1].value)/cur_n
      running_averages[1].value.push(new_sam)
      
      var old = running_averages[2].value[prev_n]
      var new_mea = ((old * prev_n) + estimates[2].value)/cur_n
      running_averages[2].value.push(new_mea)
    
      running_averages[0].id.push(cur_n)
      running_averages[1].id.push(cur_n)
      running_averages[2].id.push(cur_n)

}

  function updateVisibility() {
  
    var params = ["mean", "population", "sample"]
    
    for (var i = 0; i < 3; i++) {
      var param = params[i]
      var elementIds = "#" + param + "-estimate, #" + param + "-line"
      
      populationAndSampleSvg.selectAll(elementIds).classed("hide", legendStatus[i].hide)
      <!-- populationAndSampleSvg.selectAll("#" + param + "-estimate").classed("hide", legendStatus[i].hide) -->
      timeSvg.selectAll("#" + param + "-path").classed("hide", legendStatus[i].hide)
    }
  }
  
}

```

:::{.content-hidden}
# Helper functions
:::

```{ojs}

dodger = radius => {
  const radius2 = radius ** 1.9;
  const bisect = d3.bisector(d => d.x);
  const circles = [];
  return x => {
    const l = bisect.left(circles, x - radius);
    const r = bisect.right(circles, x + radius, l);
    let y = 0;
    for (let i = l; i < r; ++i) {
      const { x: xi, y: yi } = circles[i];
      const x2 = (xi - x) ** 2;
      const y2 = (yi - y) ** 2;
      if (radius2 > x2 + y2) {
        y = yi + Math.sqrt(radius2 - x2) + 1e-6;
        i = l - 1;
        continue;
      }
    }
    circles.splice(bisect.left(circles, x, l, r), 0, { x, y });
    <!-- populationPanelHeight * 0.7 - d.cy + (radius * 2) -->
    return y;
  };
}

dodge = dodger(radius * 2 + 0.75);
```

```{ojs}

function mean(array) {
    return array.reduce((a, b) => a + b) / array.length;
}

function sample_variance(array) {
    const n = array.length
    const m = mean(array)
    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / (n - 1);
}

function population_variance(array) {
    const n = array.length
    const m = mean(array)
    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / n;
}

function get_descriptives (array) {
    return {mean: mean(array),
            sample_variance: sample_variance(array) - 1, 
            population_variance: population_variance(array) - 1}
}

function getNewData (array) {
    
    return {sample_estimates: getSampleEstimates(array)
            <!-- running_averages: getRunningAverages(array) -->
            }
}

function getSampleEstimates(array) {
    return [{param: "population", value: population_variance(array) - 1},
            {param: "sample",     value: sample_variance(array) - 1},
            {param: "mean",       value: mean(array)}]
}

```

::: {.content-hidden}
# CSS
:::

```{css}

:root {
  --population-color: pink;
  --sample-color: var(--link-color);
  --mean-color: purple;
  --mu-color: purple;
  --sigma-color: var(--link-color);
}

.g-row {
  width: 100%;
}

/* for desktop */
#population-container {
  float: left; 
  width: 60%;
}

#timeline-container {
float: right;
  width: 40%;
}

@media screen and (max-width: 600px) {
  #population-container {
    width: 100%;
  }

  #timeline-container {
    width: 100%;
  }
}

@media screen and (min-width: 600px) {
  #population-container {
    width: 60%;
  }

  #estimates-container {
    width: 40%;
  }
}



.axis {
  font-size: 0.75em;
}
.bias-chart-title {
  font-size: 1.2em;
}
.axis-major {
  stroke: #aaa;
  stroke-width: 1;
}
.axis-minor {
  stroke: #ddd;
  stroke-width: 1;
}


.sample {
  stroke: white;
}

#sample-estimate, #sample-line, #sample-legend {
  fill: var(--sample-color);
  stroke: var(--sample-color);
}

#mean-estimate, #mean-line, #mean-legend {
  fill:   var(--mean-color);
  stroke: var(--mean-color);
}

#population-estimate, #population-line, #population-legend {
  fill:   var(--population-color);
  stroke: var(--population-color);
}

.legend-unselected {
  fill-opacity: 0.1 !important;
}


.bias-paths {
  fill: none;
  stroke-width: 2;
}

#mean-path {
  stroke: var(--mean-color);
}
#sample-path {
  stroke: var(--sample-color);
}
#population-path {
  stroke: var(--population-color);
}

.hide {
  fill: none !important;
  stroke: none !important;
}


.button {
   font-family: Times;
}
.button:hover {
  fill: red;
  cursor: pointer;
}


.legend-dots:hover {
  cursor: pointer;
}


.selector {
  margin-right: 2em;
  cursor: pointer;
}
.selector::after {
  content: "";
  display: inline-block;
  width: 10px;
  height: 10px;
  transform: translate(50%, -10%) rotate(45deg);
}

.select-mean::after {
  background-color: var(--mean-color);
  border: 1px solid var(--mean-color);
}
.select-mean::after .unselected {
  background-color: "black";
  border: 1px solid var(--mean-color);
}
.select-population::after {
  background-color: var(--population-color);
  border: 1px solid var(--population-color);
}
.select-sample::after {
  background-color: var(--sample-color);
  border: 1px solid var(--sample-color);
}

.unselected::after {
  opacity: 0.2;
}

.unselected:hover::after {
  opacity: 0.5;
}

```

