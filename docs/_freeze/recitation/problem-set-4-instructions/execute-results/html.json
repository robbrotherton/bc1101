{
  "hash": "24c39304ad54c4efbfd919fadc24969c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Problem Set 4\nsubtitle: $z$-scores and Probability\n\nformat: html\nsidebar: recitation\nnavbar: false\nexecute: \n  echo: true\n---\n\n## Finding probabilities for $z$-scores\n\nThe old-fashioned way to find the probability (the proportion of the distribution) associated with particular $z$-scores would be to look the score up in a $z$-score table (Unit Normal Table). R can do this for us much more easily, but it's a good idea to check your first few answers against a table, e.g. <https://www.westga.edu/academics/research/vrc/assets/docs/UnitNormalTable.pdf>\n\nIf you have a $z$-score in mind and want to know the associated probability, use the `pnorm()` function. By default, `pnorm()` assumes we want the proportion of the distribution to the left of the $z$-score we specify.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9772499\n```\n\n\n:::\n:::\n\n\nSo .9772499, or \\~98% of scores in a normal distribution are less than $z = 2$. Here's what that looks like:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nTo get the proportion to the right, we set the `lower.tail` argument to `FALSE` (i.e. we want the upper tail)\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(2, lower.tail = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02275013\n```\n\n\n:::\n:::\n\n\nThat tells us that \\~2% of scores are greater than $z = 2$. Here's what that looks like:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThink about how R's `lower.tail` distinction corresponds to the \"body\" vs. \"tail\" distinction. It's not always necessarily the same.\n\nTo find the proportion of the normal distribution between two $z$-scores, one way would be to subtract p(lower score) from p(higher score)\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(.25) - pnorm(-.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1974127\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nJust under .20, or 20% is between $z = -.25$ and $z = .25$. Note that the slightly different code below gives the same answer. Do you understand why? Either solution is perfectly acceptable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(-.25, lower.tail = F) - pnorm(.25, lower.tail = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1974127\n```\n\n\n:::\n:::\n\n\n## Finding $z$-scores for probabilities\n\nWhen you have a proportion in mind and want to find the associated $z$-score, `qnorm()` is the appropriate function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.644854\n```\n\n\n:::\n:::\n\n\nThat tells us that the cutoff for the lowest 5% of the distribution corresponds to $z = -1.64$. `qnorm()` also accepts the `lower.tail` argument\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(.05, lower.tail = FALSE) # Now we get a positive value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.644854\n```\n\n\n:::\n:::\n\n\nThe line below gives the same answer. Do you understand why?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(.95, lower.tail = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.644854\n```\n\n\n:::\n:::\n\n\n## Dealing with non-standardized distributions\n\nThe last thing you need to know for the questions below is that both `pnorm()` and `qnorm()` have optional arguments for the mean and SD of the distribution. That is, if we have raw scores, we don't have to convert to $z$-scores to use these functions, we can just specify the appropriate values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(130, mean = 100, sd = 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9772499\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"false\"}\n## Sketching distributions\n\nDo you find the graphs in the instructions above helpful? With the kinds of questions in this problem set, I find it massively useful to sketch a rough normal curve on a piece of paper and mark approximately where the $z$-scores would go, and shade in the corresponding probability region. My strong recommendation is that you do that on a piece of paper.\n\nIf are falling in love with R and `ggplot` in particular, however, you can draw distributions right in your problem set using `ggplot`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot() +\n  stat_function(fun = dnorm, \n                geom = \"density\", \n                xlim = c(-2, 2), \n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nThe first `stat_function()` layer draws the red shaded region, and the second one draws the black line of the full normal curve. I picked `c(-4, 4)` for the `xlim`s of the full curve because that's wide enough to show the ends tailing off to 0. For the shaded region, `c(-2, 2)` was just an arbitrary choice.\n\nSay you wanted to shade the region below $z = 2$. You could use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  stat_function(fun = dnorm, \n                geom = \"density\", \n                xlim = c(-4, 2), # xlim goes up to 2\n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThat gives you a good visual sense that most of the distribution is below that point, so when `pnorm(2)` gives you the answer, it should make sense.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9772499\n```\n\n\n:::\n:::\n\n\nOr say you want to see what the highest 20% of the distribution looks like.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  stat_function(fun = dnorm, geom = \"density\", \n                xlim = c(qnorm(0.2, lower.tail = FALSE), 4), \n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nOr a region of 40% in the middle of the distribution, separating 30% in each tail:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  stat_function(fun = dnorm, geom = \"density\", \n                xlim = c(qnorm(0.3), qnorm(0.3, lower.tail = FALSE)), \n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nYou could even turn this into a convenient function...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_distribution <- function(lower_z = -4, upper_z = 4) {\n  \n  ggplot() +\n  stat_function(fun = dnorm, \n                geom = \"density\", \n                xlim = c(lower_z, upper_z), # xlim goes up to 2\n                fill = \"red\", color = NA) +\n  stat_function(fun = dnorm, xlim = c(-4, 4))\n\n}\n\nplot_distribution(-2, 2)\n```\n\n::: {.cell-output-display}\n![](problem-set-4-instructions_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nI'm not saying this will make your life easier: you still have to know your way around `ggplot()`, `pnorm()`, `qnorm()`, and the idea of chopping the distribution into different regions. But it can be satisfying to produce a visual reference corresponding to your numeric answer.\n:::\n",
    "supporting": [
      "problem-set-4-instructions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}