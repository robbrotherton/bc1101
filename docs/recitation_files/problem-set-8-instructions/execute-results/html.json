{
  "hash": "6e05d97c6b575d55838b05e68cc818b6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Problem Set 8\nsubtitle: Independent and Repeated-Measures ANOVA\n\nformat: html\nsidebar: recitation\nnavbar: false\nexecute: \n  echo: true\n---\n\n# Part 1: ANOVA using R functions.\n\n::: {.content-hidden when-format=\"pdf\"}\n## Instructions\n\nThe `aov()` function can be used to perform ANOVA on data in a data.frame. The arguments supplied to `aov()` are `formula` and `data` (the name of the data.frame containing the relevant data). The formula specifies the DV and grouping variable, in the form `DV ~ IV`, meaning we want to compare scores on the DV broken into groups according to the IV.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(formula = DV ~ IV, data = my_data)\n```\n:::\n\n\nFor data from a within-subjects design, you need to include a participant error term in the formula. It will look something like this, where `participant` is the name of a column identifying each participant in your data (note the capital E in `Error`!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\naov(formula = DV ~ IV + Error(participant/IV), data = my_data)\n```\n:::\n\n\nSince the `aov()` function requires a formula, it is important to have the data you are using in the correct format. For question 1, the data you are given is in what's called 'wide' format, meaning there are separate columns for each condition of the IV. For the `formula` argument to work, that data must be in 'long' format, meaning just one column for the IV and one for DV scores. Remember to switch the data from one format to the other using the `pivot_longer()` function from the `tidyr` package (like we have practiced in some previous problem sets).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\ndata_long <- my_data |> \n  pivot_longer(everything())\n```\n:::\n\n\nIf there is a column identifying participants, as is typical for a within-subjects design, you **don't** want that to be pivoted; rather it should get duplicated as another column identifying which participant each score came from. Accordingly, rather than pivoting `everything()`, you can exclude the `id_column` (whatever it is named) using the syntax `-id_column`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_long_within <- my_data |> \n  pivot_longer(-id_column)\n```\n:::\n\n\nMake sure to look at your newly reshaped dataframes and understand how the format has been changed without altering the actual recorded data. Also, make note of the column names (or change them), which you will need to specify in following analyses.\n\nThe output that `aov()` produces isn't very useful by itself. E.g. it doesn't give us an $F$ value or significance level. To get those, we need to use the `summary()` function in combination with `aov()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_between <- aov(formula = DV ~ IV, data = data_long)\nsummary(model_between)\n```\n:::\n\n\n### Effect size\n\nFor ANOVA, the most commonly-reported measure of effect size is eta-squared, $\\eta^2$, or partial eta-squared, $\\eta^2_p$. The `effectsize` package has an `eta_squared` function which accepts a model produced by `aov()` and returns that measure of effect size. It works for between- or within-participants models; for the latter you can specify `partial = TRUE` as an argument within the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neffectsize::eta_squared(model_between)\neffectsize::eta_squared(model_within, partial = TRUE)\n```\n:::\n\n\n### Post-hoc tests\n\nThere is a function that makes performing a Tukey test easy: R's built-in `TukeyHSD()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTukeyHSD(model_between)\n```\n:::\n\n\nHowever, `TukeyHSD()` also only works with between-participants models; for a within-participants model you'll need to use the mathematical approach from the lectures, using $MS_{error}$ and $df_{error}$. You will find these values in the output of the `summary()` function.\n\nYou'll also need the $q$ statistic, which you can find using `qtukey()`.  This works just like our old friends `qnorm()` and `qt()`--you specify a proportion (e.g. .05) and it tells you the corresponding $q$ statistic. Some other arguments are required as well though:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq <- qtukey(p = 0.05, nmeans = 3, df = 10, lower.tail = FALSE)\n```\n:::\n\n\n…where `p` = alpha, `nmeans` = $k$, and `df` = $df_{within}$. The resulting $q$ value should be used in the calculation \n\n$$q * \\sqrt{\\dfrac{MSwithin}{n}}$$\n\nThis tells you the size of difference between means required to count as statistically significant.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}